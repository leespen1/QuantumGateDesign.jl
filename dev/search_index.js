var documenterSearchIndex = {"docs":
[{"location":"#HermiteOptimalControl.jl-Documentation","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"","category":"page"},{"location":"#Workflow","page":"HermiteOptimalControl.jl Documentation","title":"Workflow","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"Right now the user can set up Schrodinger problems, and compute the gradients of them with the control vector and target gate of their choosing. In a complete package, there would also be an optimization procedure which uses this gradient calculation.","category":"page"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"The basic workflow is:","category":"page"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"Set up a SchrodingerProblem, either yourself using the constructor SchrodingerProb, or by using one of the example problems provided. Schrodinger Problem Examples\nChoose a control vector and target.\nCompute a gradient using one of the methods provided. Gradient Evaluation","category":"page"},{"location":"#Functions","page":"HermiteOptimalControl.jl Documentation","title":"Functions","text":"","category":"section"},{"location":"#Schrodinger-Problem-Definition","page":"HermiteOptimalControl.jl Documentation","title":"Schrodinger Problem Definition","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"SchrodingerProb","category":"page"},{"location":"#Schrodinger-Problem-Examples","page":"HermiteOptimalControl.jl Documentation","title":"Schrodinger Problem Examples","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"rabi_osc\ngargamel_prob\nbspline_prob","category":"page"},{"location":"#Forward-Evolution","page":"HermiteOptimalControl.jl Documentation","title":"Forward Evolution","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"Functions for evolving the state vector in a problem forward in time according to Schrodinger's equation, with or without forcing.","category":"page"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"eval_forward\neval_forward_forced","category":"page"},{"location":"#HermiteOptimalControl.eval_forward","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.eval_forward","text":"Evolve a vector SchrodingerProblem forward in time. Return the history of the state vector (u/v) in a 3-index array, where the first index of corresponds to the vector component, the second index corresponds to the derivative to be taken, and the third index corresponds to the timestep number.\n\n\n\n\n\n","category":"function"},{"location":"#Gradient-Evaluation","page":"HermiteOptimalControl.jl Documentation","title":"Gradient Evaluation","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"discrete_adjoint\neval_grad_forced\neval_grad_finite_difference\ninfidelity","category":"page"},{"location":"#HermiteOptimalControl.discrete_adjoint","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.discrete_adjoint","text":"Arbitrary order version, should make one with target being abstract vector as well, so I can do state transfer problems.\n\n\n\n\n\n","category":"function"},{"location":"#HermiteOptimalControl.infidelity","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.infidelity","text":"Calculates the infidelity for the given state vector 'Ïˆ' and target state 'target.'\n\nReturns: Infidelity\n\n\n\n\n\nCalculates the infidelity for the given matrix of state vectors 'Q' and matrix of target states 'target.'\n\nReturns: Infidelity\n\n\n\n\n\n","category":"function"},{"location":"#Bsplines","page":"HermiteOptimalControl.jl Documentation","title":"Bsplines","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"bcparams\nbcarrier2\nbcarrier2_dt\ngradbcarrier2!\ngradbcarrier2_dt!","category":"page"}]
}
